# 五大模式与 TOML 策略文件的关联机制深度解析

Gemini CLI 的权限系统并非简单的 "一种模式加载一个文件"，而是采用 **"全量加载 + 动态过滤"** 的机制。所有的 TOML 文件都会被加载到内存中，策略引擎根据当前模式实时匹配生效的规则。

## 1. 五大模式与 TOML 的关联关系

系统启动时，会扫描 `packages/core/src/policy/policies/` 目录下的所有 TOML 文件。

| 模式 (Mode) | 核心关联 TOML | 关键机制 |
| :--- | :--- | :--- |
| **Plan Mode** | `plan.toml` | 包含一条 **Priority 20** 的全局 Deny 规则。由于其他默认规则优先级较低 (如 write.toml 为 10)，这条规则会覆盖它们，实现 "只读"。 |
| **Default Mode** | `write.toml`<br>`read-only.toml` | 没有任何特殊的高优先级覆盖规则。系统回退到 `write.toml` 中定义的基准策略 (写操作/Shell = Ask User, Priority 10)。 |
| **AutoEdit Mode** | `write.toml` | 利用 TOML 中的 `modes` 字段。`write.toml` 中包含特定规则指明 `modes = ["autoEdit"]`，将写操作权限从 Ask User 提升为 Allow。 |
| **Yolo Mode** | `yolo.toml` | 包含一条 **Priority 999** 的全局 Allow 规则。这个极高的优先级会 "击穿" 所有其他限制规则。 |
| **Shell Mode** | (无独立文件) | Shell 模式在底层复用当前激活的 Approval Mode (通常是 Default 或 Yolo) 的策略。 |

### 核心代码证据
在 `packages/core/src/policy/toml-loader.ts` 中，所有规则被加载。在 `packages/core/src/policy/policy-engine.ts` 中进行匹配：

```typescript
// 伪代码逻辑展示匹配过程
for (const rule of allRules) {
  // 1. 检查模式是否匹配
  if (rule.modes && !rule.modes.includes(currentMode)) {
    continue; // 如果规则指定了模式但与当前不符，跳过
  }
  
  // 2. 检查工具名和参数
  if (matchTool(rule, toolCall)) {
    return rule.decision; // 找到最高优先级的匹配规则
  }
}
```

## 2. TOML 文件的具体匹配逻辑

CLI **不会** 根据模式去 "选择性加载" 文件。相反，它是通过 **优先级 (Priority)** 和 **模式标签 (Modes)** 两个维度来控制生效逻辑。

### 示例分析

**场景 1: Plan Mode 下的 `run_shell_command`**
1.  加载 `plan.toml`: 包含 `toolName = "*", decision = "deny", priority = 20`。
2.  加载 `write.toml`: 包含 `toolName = "run_shell_command", decision = "ask_user", priority = 10`。
3.  **结果**: Priority 20 > 10，所以 **Deny** 生效。

**场景 2: AutoEdit Mode 下的 `write_file`**
1.  加载 `write.toml`:
    *   规则 A: `toolName = "write_file", decision = "ask_user", priority = 10` (通用)
    *   规则 B: `toolName = "write_file", decision = "allow", priority = 15, modes = ["autoEdit"]` (特定模式)
2.  **结果**: 当前是 AutoEdit 模式，规则 B 生效 (Priority 15 > 10)，所以 **自动允许**。

## 3. `discovered.toml` 是做什么用的？

**用途**: 专门用于防护 **动态发现的工具 (Dynamic Tools)**。

Gemini CLI 具有 "工具发现" 功能，可以扫描项目中的脚本并将其自动包装为 AI 可调用的工具（通常以 `discovered_tool_` 开头）。因为这些是用户项目里的任意脚本，安全性未知。

**内容解读 (`packages/core/src/policy/policies/discovered.toml`)**:
```toml
[[rule]]
toolName = "discovered_tool_*"  # 匹配所有动态发现的工具
decision = "ask_user"           # 默认策略：必须询问用户
priority = 10                   # 优先级：基础级
```

**作用**: 确保即使在 Default 模式下，AI 想要调用你项目里的某个脚本 `cleanup.sh` (被识别为 `discovered_tool_cleanup`)，也会弹出确认框，防止 AI 擅自运行未知的本地代码。
