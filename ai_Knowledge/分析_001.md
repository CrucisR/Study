# Gemini CLI 五大模式深度技术分析：命令执行与文件权限 (分析_001)

本文档基于 `packages/core/src/` 下的源码分析，详细对比 Gemini CLI 五种模式（Plan, Default, AutoEdit, Yolo, Shell）在命令执行与文件系统权限上的差异，并深入解析其底层的防护机制与配置原理。

## 1. 核心结论概览

| 特性 | Plan Mode | Default Mode | AutoEdit Mode | Yolo Mode | Shell Mode (概念) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **文件读取** | ✅ 允许 | ✅ 允许 | ✅ 允许 | ✅ 允许 | - |
| **文件修改** | ❌ 拒绝 (仅限 Plan 目录) | ❓ 询问用户 | ✅ 允许 (信任编辑) | ✅ 允许 | - |
| **Shell 执行** | ❌ 拒绝 | ❓ 询问用户 | ❓ 询问用户 (未放宽) | ✅ 允许 | 需视主模式而定 |
| **越权文件访问** | 🛡️ 严格拦截 | 🛡️ 严格拦截 | 🛡️ 严格拦截 | 🛡️ 严格拦截 | - |
| **越权命令参数** | - | ⚠️ 依赖人工审核 | ⚠️ 依赖人工审核 | ⚠️ 无防护 (高危) | - |

> **注**: "Shell Mode" 在源码 `ApprovalMode` 枚举中并不作为独立模式存在，它通常指代用户在交互式终端中专注于 Shell 操作的状态，其底层权限遵循当前激活的 Approval Mode (通常是 Default 或 Yolo)。

---

## 2. 命令执行权限深度解析

### 2.1 只有 bash 工具用于操控执行 shell 吗？

**源码分析结论**:
主要工具是 `run_shell_command`。
在 `packages/core/src/policy/policy-engine.ts` 中，系统通过 `SHELL_TOOL_NAMES` 常量来识别 Shell 类工具。
虽然底层支持 `node-pty` (伪终端) 和 `child_process`，但它们都统一封装在 `run_shell_command` 这一工具接口下暴露给 AI 模型。

### 2.2 五大模式下的 Shell 权限默认情况

权限由 `packages/core/src/policy/policies/` 下的 TOML 文件定义：

1.  **Plan Mode (`plan.toml`)**:
    *   **策略**: **Deny All**。
    *   **实现**: `priority = 20` 的全局 `deny` 规则。且 `run_shell_command` 不在白名单中。
    *   **结果**: **无法执行任何命令**。

2.  **Default Mode**:
    *   **策略**: **Ask User**。
    *   **实现**: `write.toml` 中定义了 `run_shell_command` 的规则，`decision = "ask_user"`, `priority = 10`。
    *   **结果**: AI 发起命令请求 -> CLI 暂停 -> **用户需手动点击 "Confirm"**。

3.  **AutoEdit Mode**:
    *   **策略**: **Ask User** (同 Default)。
    *   **实现**: `write.toml` 仅针对 `write_file` 和 `replace` 提升了权限 (`modes = ["autoEdit"]`, `allow`)，**并未** 针对 `run_shell_command` 提升权限。
    *   **结果**: **同 Default 模式，仍需用户确认**。这是为了防止自动编辑过程中意外执行恶意脚本。

4.  **Yolo Mode (`yolo.toml`)**:
    *   **策略**: **Allow All**。
    *   **实现**: `priority = 999` 的全局 `allow` 规则。
    *   **结果**: **自动执行，无需确认**。

### 2.3 黑白名单机制与 "rm" 命令拦截

**问题**: 如何对特定命令（如 `rm`）设置黑白名单？具体实现机制是什么？

**实现原理 (`argsPattern`)**:
Gemini CLI 的策略引擎支持基于正则表达式的参数匹配。
代码位置: `packages/core/src/policy/policy-engine.ts` -> `ruleMatches` 函数。

```typescript
// 伪代码逻辑
if (rule.argsPattern) {
  const stringifiedArgs = stableStringify(toolCall.args);
  if (!rule.argsPattern.test(stringifiedArgs)) {
    return false; // 不匹配则跳过此规则
  }
}
```

对于 Shell 命令，参数通常是 `{"command": "rm -rf /"}`。策略引擎会用正则去匹配这个 JSON 字符串。

**配置方式 1: 简单设置 (`settings.json`)**
用户可以在 `settings.json` 中配置简单的工具级开关，但无法精细控制到命令参数（除非使用旧版语法的 hack）。
*   `tools.exclude`: 只能禁用整个 `run_shell_command` 工具。

**配置方式 2: 高级策略 (TOML) - 推荐**
这是实现 "允许 git 但禁止 rm" 的标准方式。

**示例：禁止 `rm` 命令**
创建文件 `~/.gemini/policies/block-rm.toml`:

```toml
[[rule]]
toolName = "run_shell_command"
decision = "deny"
priority = 100  # 高优先级，覆盖默认规则
# 使用正则匹配 command 参数中包含 rm 的情况
# 注意：这只是简单的字符串匹配，无法完美防御混淆攻击 (e.g. echo cm0= | base64 -d | sh)
argsPattern = '"command":".*\\brm\\b.*"'
deny_message = "rm command is blocked by security policy."
```

**示例：仅允许白名单命令 (如 git, ls)**
```toml
[[rule]]
toolName = "run_shell_command"
decision = "allow"
priority = 100
# 仅允许 git 或 ls 开头的命令
argsPattern = '"command":"(git|ls)\\b.*"'

[[rule]]
toolName = "run_shell_command"
decision = "deny"
priority = 90
deny_message = "Only git and ls are allowed."
```

---

## 3. 文件系统权限深度对比

### 3.1 核心机制：工作区禁闭 (Workspace Confinement)

**代码位置**: `packages/core/src/tools/shell.ts` 及其他工具文件。
**核心函数**: `validatePathAccess(absolutePath)`

所有涉及文件路径的工具（`read_file`, `write_file`, `run_shell_command` 的 `cwd` 参数），在执行前都会调用此函数。它检查路径是否以 `rootDirectory` (启动目录) 开头。

### 3.2 五大模式下的文件操控能力

| 场景 | Plan | Default | AutoEdit | Yolo |
| :--- | :--- | :--- | :--- | :--- |
| **读取工作区文件** | ✅ | ✅ | ✅ | ✅ |
| **修改工作区文件** | ❌ | ❓ 确认 | ✅ 自动 | ✅ 自动 |
| **新增工作区文件** | ❌ | ❓ 确认 | ✅ 自动 | ✅ 自动 |
| **读取系统文件 (/etc/hosts)** | 🛡️ 拦截 | 🛡️ 拦截 | 🛡️ 拦截 | 🛡️ 拦截 |
| **修改系统文件** | 🛡️ 拦截 | 🛡️ 拦截 | 🛡️ 拦截 | 🛡️ 拦截 |

**特别说明**: 上表中的 "拦截" 指的是 **直接工具调用** (如 `read_file('/etc/hosts')`)。

### 3.3 间接越权风险：Shell 命令的漏洞

**问题**: 用户能否通过命令执行的方式，间接操控启动目录以外的文件？

**结论**: **可以 (如果 Shell 工具被允许执行)**。

**原理分析**:
虽然 CLI 限制了 Shell 进程的 **启动目录 (CWD)** 必须在工作区内，但它 **无法解析和限制 Shell 命令内部的参数**。

*   **场景**: AI 执行 `run_shell_command(command="cat /etc/passwd", dir_path="/workspace")`。
*   **校验流程**:
    1.  `dir_path` ("/workspace") -> ✅ 通过 `validatePathAccess`。
    2.  `command` 字符串 -> ❌ **未进行路径校验** (技术上极难实现完美的 Shell AST 路径审计)。
    3.  **结果**: 命令被传递给系统 Shell 执行。

**五大模式下的防护策略**:

1.  **Plan Mode**:
    *   **防护**: 直接禁止 `run_shell_command` 工具。
    *   **安全级别**: ⭐⭐⭐⭐⭐ (绝对安全)

2.  **Default / AutoEdit Mode**:
    *   **防护**: 策略为 `ask_user`。
    *   **机制**: 屏幕显示 `Command: cat /etc/passwd`，等待用户审批。
    *   **安全级别**: ⭐⭐⭐ (依赖用户警惕性)

3.  **Yolo Mode**:
    *   **防护**: **无**。
    *   **后果**: AI 可以直接读取或修改系统文件（只要当前运行 CLI 的用户有 OS 权限）。
    *   **安全级别**: ⭐ (高危)

### 3.4 终极防护：如何彻底无法操控系统文件？

如果仅依赖代码层面的 `validatePathAccess` 和策略配置，始终存在 Shell 绕过的风险。
**唯一有效的系统级防护是 Sandboxing (沙盒)**。

*   **Docker 容器**:
    将 CLI 运行在 Docker 中。CLI 只能看到容器内的文件系统。即使 AI 执行 `rm -rf /`，也只是删除了容器环境，宿主机毫发无损。
*   **macOS Sandbox**:
    使用 `gemini --sandbox` 启动，利用 macOS 内核级 Seatbelt 机制，从操作系统底层禁止进程访问未授权目录。

---

## 4. 总结

1.  **权限分界**: Gemini CLI 的权限控制主要依赖 **工具级拦截** (Policy Engine) 和 **路径级校验** (Path Checker)。
2.  **Shell 是最大的缺口**: 虽然文件工具被严格限制在工作区，但 Shell 工具一旦开启，就像打开了一扇通往系统的门。
3.  **模式选择**:
    *   日常开发建议使用 **Default** 或 **AutoEdit**，它们保留了 "最后一道防线" —— 人工确认。
    *   **Plan** 模式是绝对安全的只读模式。
    *   **Yolo** 模式应仅在沙盒环境或完全信任的任务中使用。
