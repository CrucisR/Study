# 五大模式与交互/非交互模式完整分析报告

## 目录
1. [交互模式与非交互模式概述](#交互模式与非交互模式概述)
2. [目录权限与路径校验机制](#目录权限与路径校验机制)
3. [五大模式与交互/非交互模式的关联](#五大模式与交互非交互模式的关联)
4. [文件路径操控对比](#文件路径操控对比)
5. [命令执行路径校验对比](#命令执行路径校验对比)
6. [总结](#总结)

---

## 交互模式与非交互模式概述

### 交互模式（Interactive Mode）

**定义**：系统可以与用户进行实时交互的运行模式。

**特点**：
- 可以请求用户确认操作
- 支持多次对话
- 绝对路径可以直接访问（不进行工作区校验）
- 适合探索性工作和开发环境

**启用方式**：
```bash
# 默认模式（在 TTY 环境下）
gemini

# 使用 -i/--prompt-interactive 参数
gemini -i "初始提示"
gemini --prompt-interactive "初始提示"
```

**判断逻辑**（[config.ts:587-591](file:///d:\Code_AI\gemini-cli\packages\cli\src\config\config.ts#L587-L591)）：
```typescript
const interactive =
  !!argv.promptInteractive ||
  !!argv.experimentalAcp ||
  (process.stdin.isTTY && !argv.query && !argv.prompt && !argv.isCommand);
```

### 非交互模式（Non-Interactive Mode）

**定义**：系统无法与用户进行实时交互的运行模式。

**特点**：
- 无法请求用户确认，ASK_USER 自动转为 DENY
- 只能执行一次性任务
- 所有路径都必须在工作区内（严格校验）
- 适合 CI/CD 自动化和批处理脚本

**启用方式**：
```bash
# 使用 -p/--prompt 参数
gemini -p "执行任务"
gemini --prompt "执行任务"

# 从管道输入
echo "任务" | gemini
```

**PolicyEngine 处理**（[policy-engine.ts:474-478](file:///d:\Code_AI\gemini-cli\packages\core\src\policy\policy-engine.ts#L474-L478)）：
```typescript
private applyNonInteractiveMode(decision: PolicyDecision): PolicyDecision {
  if (this.nonInteractive && decision === PolicyDecision.ASK_USER) {
    return PolicyDecision.DENY;
  }
  return decision;
}
```

### 两种模式对比

| 特性 | 交互模式 | 非交互模式 |
|------|----------|-----------|
| 默认值 | true（TTY 环境） | false |
| 用户确认 | 可以请求 | 自动拒绝（DENY） |
| 绝对路径访问 | 直接允许 | 必须在工作区内 |
| 相对路径访问 | 必须在工作区内 | 必须在工作区内 |
| 对话次数 | 多次 | 一次性 |
| 适用场景 | 日常开发、IDE 集成 | CI/CD、自动化脚本 |

---

## 目录权限与路径校验机制

### 路径校验核心函数

#### isPathWithinWorkspace

**位置**：[workspaceContext.ts](file:///d:\Code_AI\gemini-cli\packages\core\src\utils\workspaceContext.ts)

**核心实现**：
```typescript
isPathWithinWorkspace(pathToCheck: string): boolean {
  try {
    const fullyResolvedPath = this.fullyResolvedPath(pathToCheck);
    for (const dir of this.directories) {
      if (this.isPathWithinRoot(fullyResolvedPath, dir)) {
        return true;
      }
    }
    return false;
  } catch (_error) {
    return false;
  }
}
```

**验证逻辑**：
1. 解析路径为绝对路径
2. 遍历所有工作区目录
3. 计算相对路径
4. 检查是否在工作区范围内

#### isPathAllowed

**位置**：[config.ts:1771-1794](file:///d:\Code_AI\gemini-cli\packages\core\src\config\config.ts#L1771-L1794)

**核心实现**：
```typescript
isPathAllowed(absolutePath: string): boolean {
  // 交互模式下，绝对路径直接允许
  if (this.interactive && path.isAbsolute(absolutePath)) {
    return true;
  }

  // 非交互模式或交互模式的相对路径，进行工作区校验
  const realpath = (p: string) => {
    let resolved: string;
    try {
      resolved = fs.realpathSync(p);
    } catch {
      resolved = path.resolve(p);
    }
    return os.platform() === 'win32' ? resolved.toLowerCase() : resolved;
  };

  const resolvedPath = realpath(absolutePath);

  const workspaceContext = this.getWorkspaceContext();
  if (workspaceContext.isPathWithinWorkspace(resolvedPath)) {
    return true;
  }

  const projectTempDir = this.storage.getProjectTempDir();
  const resolvedTempDir = realpath(projectTempDir);

  return isSubpath(resolvedTempDir, resolvedPath);
}
```

**关键逻辑**：
- **交互模式 + 绝对路径**：直接允许，不进行工作区校验
- **交互模式 + 相对路径**：检查是否在工作区内
- **非交互模式 + 绝对路径**：检查是否在工作区内
- **非交互模式 + 相对路径**：检查是否在工作区内

### 路径校验流程图

```
用户请求访问路径
    ↓
判断交互模式
    ↓ (交互模式 + 绝对路径)
直接允许访问
    ↓ (交互模式 + 相对路径)
调用 isPathWithinWorkspace
    ↓ (非交互模式)
调用 isPathWithinWorkspace
    ↓
解析路径为绝对路径
    ↓
遍历所有工作区目录
    ↓
计算相对路径 path.relative(root, path)
    ↓
检查相对路径是否以 '..' 开头
    ↓ (是)
拒绝访问
    ↓ (否)
允许访问
```

### 路径类型对比

| 路径类型 | 交互模式 | 非交互模式 | 校验逻辑 |
|----------|----------|-----------|----------|
| 绝对路径 | 直接允许 | 严格校验 | 交互模式跳过校验 |
| 相对路径 | 严格校验 | 严格校验 | 都需要工作区校验 |
| 工作区内 | 允许 | 允许 | 通过 isPathWithinWorkspace |
| 工作区外 | 允许（交互） | 拒绝 | 交互模式例外 |
| 临时目录 | 允许 | 允许 | 通过 isSubpath 检查 |

---

## 五大模式与交互/非交互模式的关联

### ApprovalMode 定义

**位置**：[types.ts:46-49](file:///d:\Code_AI\gemini-cli\packages\core\src\policy\types.ts#L46-L49)

```typescript
export enum ApprovalMode {
  DEFAULT = 'default',
  AUTO_EDIT = 'autoEdit',
  YOLO = 'yolo',
  PLAN = 'plan',
}
```

### 两个维度的独立性

**关键点**：ApprovalMode 和 interactive 是两个完全独立的配置维度。

| 维度 | 控制内容 | 配置方式 | 决策类型 |
|------|----------|----------|----------|
| ApprovalMode | 工具执行的审批策略 | --approval-mode 参数 | ALLOW/ASK_USER/DENY |
| interactive | 路径验证和用户确认能力 | 命令行参数 | true/false |

### 理论组合

存在 **4 × 4 = 16 种组合**：

| ApprovalMode | 交互模式 | 非交互模式 |
|-------------|----------|-----------|
| **DEFAULT** | 写工具需要用户确认 | 写工具自动拒绝（ASK_USER → DENY） |
| **AUTO_EDIT** | 写工具自动允许 | 写工具自动允许 |
| **YOLO** | 所有工具自动允许 | 所有工具自动允许 |
| **PLAN** | 只读操作，写操作拒绝 | 只读操作，写操作拒绝 |

### 各模式的策略配置

#### DEFAULT 模式

**策略文件**：[write.toml](file:///d:\Code_AI\gemini-cli\packages\core\src\policy\policies\write.toml)

```toml
[[rule]]
toolName = "write_file"
decision = "ask_user"
priority = 10
```

**行为**：
- 交互模式：需要用户确认
- 非交互模式：自动拒绝

#### AUTO_EDIT 模式

**策略文件**：[write.toml](file:///d:\Code_AI\gemini-cli\packages\core\src\policy\policies\write.toml)

```toml
[[rule]]
toolName = "write_file"
decision = "allow"
priority = 15
modes = ["autoEdit"]

[rule.safety_checker]
type = "in-process"
name = "allowed-path"
required_context = ["environment"]
```

**行为**：
- 交互模式：写操作自动允许
- 非交互模式：写操作自动允许

#### YOLO 模式

**策略文件**：[write.toml](file:///d:\Code_AI\gemini-cli\packages\core\src\policy\policies\write.toml)

```toml
[[rule]]
decision = "allow"
priority = 999
modes = ["yolo"]
```

**行为**：
- 交互模式：所有操作自动允许
- 非交互模式：所有操作自动允许
- 优先级最高（999），覆盖其他规则

#### PLAN 模式

**策略文件**：[plan.toml](file:///d:\Code_AI\gemini-cli\packages\core\src\policy\policies\plan.toml)

```toml
# PLAN 模式下默认拒绝所有操作
[[rule]]
decision = "deny"
priority = 20
modes = ["plan"]

# 但允许只读工具
[[rule]]
toolName = "read_file"
decision = "allow"
priority = 50
modes = ["plan"]
```

**行为**：
- 交互模式：只读操作，写操作拒绝
- 非交互模式：只读操作，写操作拒绝

### 非交互模式下的工具排除

**位置**：[config.ts:595-622](file:///d:\Code_AI\gemini-cli\packages\cli\src\config\config.ts#L595-L622)

```typescript
if (!interactive) {
  const defaultExcludes = [
    SHELL_TOOL_NAME,      // shell 命令
    EDIT_TOOL_NAME,       // 编辑工具
    WRITE_FILE_TOOL_NAME,  // 写文件工具
    WEB_FETCH_TOOL_NAME,   // 网络请求
  ];

  switch (approvalMode) {
    case ApprovalMode.PLAN:
      extraExcludes.push(...defaultExcludes.filter(toolExclusionFilter));
      break;
    case ApprovalMode.DEFAULT:
      extraExcludes.push(...defaultExcludes.filter(toolExclusionFilter));
      break;
    case ApprovalMode.AUTO_EDIT:
      extraExcludes.push(...autoEditExcludes.filter(toolExclusionFilter));
      break;
    case ApprovalMode.YOLO:
      // No extra excludes for YOLO mode.
      break;
  }
}
```

**排除策略**：
- **PLAN 模式**：排除所有需要确认的工具
- **DEFAULT 模式**：排除所有需要确认的工具
- **AUTO_EDIT 模式**：只排除需要提示的工具（shell）
- **YOLO 模式**：不排除任何工具

---

## 文件路径操控对比

### 文件操作工具列表

以下工具都会进行路径验证：
1. **write_file** - 写入文件
2. **read_file** - 读取文件
3. **read_many_files** - 批量读取文件
4. **ls** - 列出目录
5. **edit** - 编辑文件
6. **grep** - 搜索文件内容
7. **glob** - 查找文件

### 路径校验调用链

```
工具执行
    ↓
调用 validatePathAccess(absolutePath)
    ↓
调用 isPathAllowed(absolutePath)
    ↓
检查 interactive 模式
    ↓ (交互模式 + 绝对路径)
直接允许
    ↓ (其他情况)
调用 isPathWithinWorkspace(resolvedPath)
    ↓
遍历工作区目录
    ↓
计算相对路径
    ↓
检查是否在工作区内
    ↓ (否)
返回错误: "Path not in workspace"
    ↓ (是)
继续执行文件操作
```

### 五大模式 × 交互/非交互模式 × 路径类型对比表

| ApprovalMode | 交互模式 | 绝对路径 | 相对路径 | 非交互模式 | 绝对路径 | 相对路径 |
|-------------|----------|----------|----------|-----------|----------|----------|
| **DEFAULT** | 交互 | ✅ 直接允许 | ⚠️ 需要校验 | 非交互 | ❌ 严格校验 | ❌ 严格校验 |
| **AUTO_EDIT** | 交互 | ✅ 直接允许 | ⚠️ 需要校验 | 非交互 | ❌ 严格校验 | ❌ 严格校验 |
| **YOLO** | 交互 | ✅ 直接允许 | ⚠️ 需要校验 | 非交互 | ❌ 严格校验 | ❌ 严格校验 |
| **PLAN** | 交互 | ✅ 直接允许 | ⚠️ 需要校验 | 非交互 | ❌ 严格校验 | ❌ 严格校验 |

**图例**：
- ✅ 直接允许：不进行工作区校验
- ⚠️ 需要校验：检查是否在工作区内
- ❌ 严格校验：必须在工作区内，否则拒绝

### 关键发现

1. **交互模式的绝对路径特权**
   - 所有 ApprovalMode 下，交互模式的绝对路径都可以直接访问
   - 这是交互模式的一个重要优势

2. **非交互模式的严格性**
   - 所有路径（绝对和相对）都必须在工作区内
   - 无法访问工作区外的任何文件

3. **ApprovalMode 不影响路径校验**
   - 路径校验逻辑与 ApprovalMode 无关
   - ApprovalMode 只影响工具执行的审批策略

### 实际示例

#### 交互模式示例

```bash
# 进入交互模式
gemini

# 用户请求：读取 /etc/passwd
# 结果：允许（交互模式 + 绝对路径）

# 用户请求：读取 ../config.json
# 结果：检查是否在工作区内
```

#### 非交互模式示例

```bash
# 非交互模式
gemini -p "读取文件"

# 用户请求：读取 /etc/passwd
# 结果：拒绝（非交互模式 + 绝对路径不在工作区内）

# 用户请求：读取 ../config.json
# 结果：检查是否在工作区内
```

---

## 命令执行路径校验对比

### ShellTool 路径校验

**位置**：[shell.ts](file:///d:\Code_AI\gemini-cli\packages\core\src\tools\shell.ts)

**核心实现**：
```typescript
async execute(abortSignal: AbortSignal): Promise<ToolResult> {
  const cwd = this.params.dir_path
    ? path.resolve(this.config.getTargetDir(), this.params.dir_path)
    : this.config.getTargetDir();

  const validationError = this.config.validatePathAccess(cwd);
  if (validationError) {
    return {
      llmContent: validationError,
      returnDisplay: 'Path not in workspace.',
      error: {
        message: validationError,
        type: ToolErrorType.PATH_NOT_IN_WORKSPACE,
      },
    };
  }
  // 继续执行 shell 命令...
}
```

**校验重点**：
- 工作目录（cwd）必须在工作区内
- 命令参数中的路径也会被检查

### 命令执行路径校验流程

```
用户请求执行 shell 命令
    ↓
ShellTool 解析参数
    ↓
确定工作目录 cwd
    ↓ (指定了 dir_path)
cwd = path.resolve(targetDir, dir_path)
    ↓ (未指定 dir_path)
cwd = targetDir
    ↓
调用 validatePathAccess(cwd)
    ↓
调用 isPathAllowed(cwd)
    ↓
检查 interactive 模式
    ↓ (交互模式 + 绝对路径)
直接允许
    ↓ (其他情况)
调用 isPathWithinWorkspace(cwd)
    ↓
验证路径是否在工作区内
    ↓ (否)
返回错误: "Path not in workspace"
    ↓ (是)
PolicyEngine 检查命令策略
    ↓
检查重定向
    ↓ (有重定向且不是 AUTO_EDIT/YOLO)
降级为 ASK_USER
    ↓
执行 shell 命令
```

### 五大模式 × 交互/非交互模式 × 命令执行对比表

| ApprovalMode | 交互模式 | 工作目录 | 命令参数路径 | 非交互模式 | 工作目录 | 命令参数路径 |
|-------------|----------|----------|-------------|-----------|----------|-------------|
| **DEFAULT** | 交互 | ✅ 绝对路径允许 | ⚠️ 参数路径校验 | 非交互 | ❌ 严格校验 | ❌ 严格校验 |
| **AUTO_EDIT** | 交互 | ✅ 绝对路径允许 | ⚠️ 参数路径校验 | 非交互 | ❌ 严格校验 | ❌ 严格校验 |
| **YOLO** | 交互 | ✅ 绝对路径允许 | ⚠️ 参数路径校验 | 非交互 | ❌ 严格校验 | ❌ 严格校验 |
| **PLAN** | 交互 | ✅ 绝对路径允许 | ⚠️ 参数路径校验 | 非交互 | ❌ 严格校验 | ❌ 严格校验 |

**图例**：
- ✅ 绝对路径允许：交互模式下工作目录可以是绝对路径
- ⚠️ 参数路径校验：命令参数中的路径需要根据模式校验
- ❌ 严格校验：必须在工作区内，否则拒绝

### 重定向处理

**位置**：[policy-engine.ts:103-128](file:///d:\Code_AI\gemini-cli\packages\core\src\policy\policy-engine.ts#L103-L128)

```typescript
private shouldDowngradeForRedirection(
  command: string,
  allowRedirection?: boolean,
): boolean {
  return (
    !allowRedirection &&
    hasRedirection(command) &&
    this.approvalMode !== ApprovalMode.AUTO_EDIT &&
    this.approvalMode !== ApprovalMode.YOLO
  );
}
```

**重定向规则**：
- **DEFAULT 模式**：重定向命令降级为 ASK_USER
- **AUTO_EDIT 模式**：重定向命令保持 ALLOW
- **YOLO 模式**：重定向命令保持 ALLOW
- **PLAN 模式**：重定向命令降级为 ASK_USER

### 命令执行示例

#### 交互模式示例

```bash
# 进入交互模式
gemini

# 用户请求：cd /tmp && ls
# 结果：允许（交互模式 + 绝对路径工作目录）

# 用户请求：cat /etc/passwd
# 结果：允许（交互模式 + 绝对路径参数）
```

#### 非交互模式示例

```bash
# 非交互模式
gemini -p "执行命令"

# 用户请求：cd /tmp && ls
# 结果：拒绝（非交互模式 + 工作目录不在工作区内）

# 用户请求：cat ../config.json
# 结果：检查是否在工作区内
```

#### 非交互模式 + YOLO 示例

```bash
# 非交互模式 + YOLO
gemini -p "执行命令" --approval-mode yolo

# 用户请求：cat output.txt > result.txt
# 结果：允许（YOLO 模式 + 重定向不降级）
```

---

## 总结

### 核心概念

1. **两个独立维度**
   - **ApprovalMode**：控制工具执行的审批策略
   - **interactive**：控制路径验证和用户确认能力

2. **路径校验逻辑**
   - **交互模式 + 绝对路径**：直接允许，不进行工作区校验
   - **其他所有情况**：必须在工作区内，否则拒绝

3. **非交互模式的严格性**
   - 无法请求用户确认，ASK_USER 自动转为 DENY
   - 所有路径都必须在工作区内
   - 自动排除需要用户确认的工具

### 五大模式特点总结

| ApprovalMode | 审批策略 | 交互模式 | 非交互模式 | 适用场景 |
|-------------|----------|----------|-----------|----------|
| **DEFAULT** | 需要确认 | 写操作需要用户确认 | 写操作自动拒绝 | 日常开发 |
| **AUTO_EDIT** | 自动编辑 | 写操作自动允许 | 写操作自动允许 | 快速编辑 |
| **YOLO** | 全允许 | 所有操作自动允许 | 所有操作自动允许 | 自动化任务 |
| **PLAN** | 只读 | 只读操作，写操作拒绝 | 只读操作，写操作拒绝 | 代码审查 |

### 文件路径操控对比总结

| 场景 | 交互模式 | 非交互模式 |
|------|----------|-----------|
| **绝对路径访问** | ✅ 直接允许 | ❌ 必须在工作区内 |
| **相对路径访问** | ⚠️ 需要校验 | ⚠️ 需要校验 |
| **工作区内文件** | ✅ 允许 | ✅ 允许 |
| **工作区外文件** | ✅ 允许（交互） | ❌ 拒绝 |
| **临时目录** | ✅ 允许 | ✅ 允许 |

### 命令执行路径校验对比总结

| 场景 | 交互模式 | 非交互模式 |
|------|----------|-----------|
| **工作目录** | ✅ 绝对路径允许 | ❌ 必须在工作区内 |
| **命令参数路径** | ⚠️ 根据模式校验 | ⚠️ 根据模式校验 |
| **重定向命令** | ⚠️ 降级为 ASK_USER | ⚠️ 降级为 DENY |
| **YOLO 模式** | ✅ 重定向不降级 | ✅ 重定向不降级 |
| **AUTO_EDIT 模式** | ✅ 重定向不降级 | ✅ 重定向不降级 |

### 最佳实践建议

#### 交互模式（推荐日常开发）

```bash
# 开发时使用交互模式
gemini

# 优势：
# - 可以访问任意绝对路径
# - 可以请求用户确认
# - 支持多次对话
```

#### 非交互模式（推荐 CI/CD）

```bash
# 自动化时使用非交互模式 + YOLO
gemini -p "执行任务" --approval-mode yolo

# 优势：
# - 自动执行，无需确认
# - 适合批处理
# - 工作区外文件自动拒绝（安全）
```

#### 安全建议

1. **生产环境**：使用非交互模式 + DEFAULT 或 PLAN
2. **开发环境**：使用交互模式 + DEFAULT 或 AUTO_EDIT
3. **自动化任务**：使用非交互模式 + YOLO
4. **代码审查**：使用 PLAN 模式（只读）

### 关键代码位置汇总

| 功能 | 文件位置 | 行号 |
|------|----------|------|
| isPathWithinWorkspace | workspaceContext.ts | - |
| isPathAllowed | config.ts | L1771 |
| validatePathAccess | config.ts | L1789 |
| interactive 判断 | config.ts (CLI) | L587 |
| PolicyEngine | policy-engine.ts | - |
| ApprovalMode | types.ts | L46-49 |
| write-file.ts | tools/write-file.ts | - |
| shell.ts | tools/shell.ts | - |

### 最终结论

**五大模式和交互/非交互模式是两个独立的维度**，它们共同决定了系统的安全策略：

- **ApprovalMode** 决定工具执行的审批级别
- **interactive** 决定路径验证的严格程度和用户确认能力

理解这两个维度的关系，可以帮助用户在不同场景下选择最合适的配置组合，既保证安全性又提高效率。
