# PLAN 模式路径写入问题深度分析报告

## 问题概述

用户报告在 PLAN 模式下可以使用绝对路径或跨目录相对路径写入非工作区外的文件。本报告深入分析该问题的根本原因。

## 核心问题分析

### 1. 关键代码位置

#### 1.1 路径验证的核心逻辑

**文件位置**: [d:\Code_AI\gemini-cli\packages\core\src\config\config.ts#L1770-L1799](file:///d:\Code_AI\gemini-cli\packages\core\src\config\config.ts#L1770-L1799)

```typescript
isPathAllowed(absolutePath: string): boolean {
  if (this.interactive && path.isAbsolute(absolutePath)) {
    return true;
  }

  const realpath = (p: string) => {
    let resolved: string;
    try {
      resolved = fs.realpathSync(p);
    } catch {
      resolved = path.resolve(p);
    }
    return os.platform() === 'win32' ? resolved.toLowerCase() : resolved;
  };

  const resolvedPath = realpath(absolutePath);

  const workspaceContext = this.getWorkspaceContext();
  if (workspaceContext.isPathWithinWorkspace(resolvedPath)) {
    return true;
  }

  const projectTempDir = this.storage.getProjectTempDir();
  const resolvedTempDir = realpath(projectTempDir);

  return isSubpath(resolvedTempDir, resolvedPath);
}
```

**关键发现**: 
- 第 1771-1773 行：**如果处于交互模式且路径是绝对路径，直接返回 true，跳过所有工作区验证！**
- 这是导致用户可以写入非工作区文件的根本原因

#### 1.2 写入文件的路径解析

**文件位置**: [d:\Code_AI\gemini-cli\packages\core\src\tools\write-file.ts#L481](file:///d:\Code_AI\gemini-cli\packages\core\src\tools\write-file.ts#L481)

```typescript
const resolvedPath = path.resolve(this.config.getTargetDir(), filePath);
```

**路径解析机制**:
- `path.resolve(base, path)` 的行为：
  - 如果 `path` 是绝对路径（如 `D:\other\file.txt`），直接返回 `path`
  - 如果 `path` 是相对路径（如 `../other/file.txt`），基于 `base` 解析

#### 1.3 交互模式的判断

**文件位置**: [d:\Code_AI\gemini-cli\packages\cli\src\config\config.ts#L587-L592](file:///d:\Code_AI\gemini-cli\packages\cli\src\config\config.ts#L587-L592)

```typescript
const interactive =
  !!argv.promptInteractive ||
  !!argv.experimentalAcp ||
  (process.stdin.isTTY && !argv.query && !argv.prompt && !argv.isCommand);
```

**交互模式判断条件**:
1. 使用 `-i/--prompt-interactive` 参数
2. 使用 `--experimental-acp` 参数
3. 在 TTY 环境下且没有使用 `-p/--prompt`、`--query` 或 `--isCommand`

### 2. 问题场景分析

#### 2.1 绝对路径写入场景

**用户操作**:
```bash
# 在交互模式下
gemini --approval-mode=plan
# 然后请求写入 D:\other\file.txt
```

**执行流程**:
1. 用户请求写入 `D:\other\file.txt`
2. `write-file.ts` 解析路径：`path.resolve(targetDir, "D:\\other\\file.txt")` → `D:\other\file.txt`
3. 调用 `validatePathAccess("D:\\other\\file.txt")`
4. `isPathAllowed("D:\\other\\file.txt")` 检查：
   - `this.interactive` 为 true（因为使用了交互模式）
   - `path.isAbsolute("D:\\other\\file.txt")` 为 true
   - **直接返回 true，跳过工作区验证**
5. 文件写入成功，尽管不在工作区内

#### 2.2 跨目录相对路径写入场景

**用户操作**:
```bash
# 假设工作区是 D:\Code_AI\gemini-cli
# 用户请求写入 ../../other/file.txt
```

**执行流程**:
1. 用户请求写入 `../../other/file.txt`
2. `write-file.ts` 解析路径：`path.resolve("D:\\Code_AI\\gemini-cli", "../../other/file.txt")` → `D:\Code\other\file.txt`
3. 调用 `validatePathAccess("D:\\Code\\other\\file.txt")`
4. `isPathAllowed("D:\\Code\\other\\file.txt")` 检查：
   - `this.interactive` 为 true
   - `path.isAbsolute("D:\\Code\\other\\file.txt")` 为 true
   - **直接返回 true，跳过工作区验证**
5. 文件写入成功，尽管不在工作区内

### 3. 交互模式 vs 非交互模式的路径验证差异

| 特性 | 交互模式 | 非交互模式 |
|------|---------|-----------|
| 绝对路径验证 | **允许所有绝对路径**（跳过验证） | 严格限制在工作区内 |
| 相对路径验证 | 基于工作区解析后验证 | 基于工作区解析后验证 |
| 跨目录相对路径 | 解析为绝对路径后允许 | 解析为绝对路径后严格验证 |
| 工作区限制 | **仅对相对路径生效** | 对所有路径生效 |

### 4. PLAN 模式与路径验证的关系

#### 4.1 PLAN 模式的工具排除

**文件位置**: [d:\Code_AI\gemini-cli\packages\cli\src\config\config.ts#L613-L618](file:///d:\Code_AI\gemini-cli\packages\cli\src\config\config.ts#L613-L618)

```typescript
case ApprovalMode.PLAN:
  // In plan non-interactive mode, all tools that require approval are excluded.
  // TODO(#16625): Replace this default exclusion logic with specific rules for plan mode.
  extraExcludes.push(...defaultExcludes.filter(toolExclusionFilter));
  break;
```

**PLAN 模式的工具排除**（仅在非交互模式下）:
- `ShellTool`
- `EditTool`
- `WriteFileTool`
- `WebFetchTool`

**关键发现**: 
- PLAN 模式在**非交互模式**下会排除 `WriteFileTool`
- 但在**交互模式**下，`WriteFileTool` 仍然可用
- 这意味着用户在交互模式下使用 PLAN 模式时，仍然可以写入文件

#### 4.2 PLAN 模式的路径验证

PLAN 模式本身不改变路径验证逻辑，路径验证完全取决于：
1. 是否处于交互模式（`this.interactive`）
2. 路径类型（绝对路径 vs 相对路径）

### 5. 根本原因总结

#### 5.1 为什么可以写入非工作区文件

**主要原因**:
1. **交互模式下的绝对路径豁免**: `isPathAllowed` 函数在交互模式下对绝对路径直接返回 true
2. **路径解析机制**: `path.resolve` 将相对路径解析为绝对路径后，也会被豁免
3. **PLAN 模式的限制**: PLAN 模式只在非交互模式下排除 `WriteFileTool`，在交互模式下不生效

#### 5.2 设计意图分析

这种设计可能基于以下考虑：
1. **交互模式的安全假设**: 在交互模式下，用户可以实时看到所有操作，因此允许更灵活的文件访问
2. **非交互模式的安全优先**: 在非交互模式下（如 CI/CD），需要更严格的安全限制
3. **用户体验**: 在交互模式下，用户可能需要访问工作区外的文件（如配置文件）

### 6. 安全风险评估

#### 6.1 高风险场景

1. **意外写入系统文件**: 用户可能意外写入系统关键文件
2. **数据泄露**: 可能读取或写入敏感文件
3. **权限提升**: 可能利用文件写入进行权限提升攻击

#### 6.2 缓解措施

1. **用户意识**: 用户需要清楚了解交互模式的权限范围
2. **路径验证增强**: 可以考虑在交互模式下也进行路径验证，但提供明确的警告
3. **工作区扩展**: 允许用户显式添加允许的目录到工作区

### 7. 建议修复方案

#### 7.1 方案一：移除交互模式的绝对路径豁免

```typescript
isPathAllowed(absolutePath: string): boolean {
  // 移除这行，或者改为警告
  // if (this.interactive && path.isAbsolute(absolutePath)) {
  //   return true;
  // }

  const realpath = (p: string) => {
    let resolved: string;
    try {
      resolved = fs.realpathSync(p);
    } catch {
      resolved = path.resolve(p);
    }
    return os.platform() === 'win32' ? resolved.toLowerCase() : resolved;
  };

  const resolvedPath = realpath(absolutePath);

  const workspaceContext = this.getWorkspaceContext();
  if (workspaceContext.isPathWithinWorkspace(resolvedPath)) {
    return true;
  }

  const projectTempDir = this.storage.getProjectTempDir();
  const resolvedTempDir = realpath(projectTempDir);

  return isSubpath(resolvedTempDir, resolvedPath);
}
```

#### 7.2 方案二：添加显式确认

在交互模式下，当访问非工作区路径时，要求用户显式确认：

```typescript
isPathAllowed(absolutePath: string): boolean {
  if (this.interactive && path.isAbsolute(absolutePath)) {
    const workspaceContext = this.getWorkspaceContext();
    if (!workspaceContext.isPathWithinWorkspace(absolutePath)) {
      // 要求用户显式确认
      const confirmed = await this.confirmAccess(absolutePath);
      return confirmed;
    }
    return true;
  }

  // ... 其余逻辑
}
```

#### 7.3 方案三：工作区扩展机制

允许用户显式添加允许的目录：

```typescript
// 添加允许的目录
config.getWorkspaceContext().addDirectory('D:\\allowed\\dir');
```

### 8. 测试验证

#### 8.1 测试场景

1. **交互模式 + 绝对路径**: 应该可以写入（当前行为）
2. **交互模式 + 跨目录相对路径**: 应该可以写入（当前行为）
3. **非交互模式 + 绝对路径**: 应该拒绝写入
4. **非交互模式 + 跨目录相对路径**: 应该拒绝写入

#### 8.2 验证命令

```bash
# 交互模式测试
gemini --approval-mode=plan

# 非交互模式测试
gemini --approval-mode=plan -p "write to D:\\other\\file.txt"
```

### 9. 结论

PLAN 模式下可以写入非工作区文件的根本原因是：
1. **交互模式下的绝对路径豁免机制**
2. **路径解析将相对路径转换为绝对路径后也会被豁免**
3. **PLAN 模式的工具排除只在非交互模式下生效**

这是一个设计上的权衡，在用户体验和安全性之间做出了选择。如果需要更严格的安全控制，可以考虑上述修复方案之一。

## 相关代码文件

- [config.ts](file:///d:\Code_AI\gemini-cli\packages\core\src\config\config.ts) - 路径验证核心逻辑
- [write-file.ts](file:///d:\Code_AI\gemini-cli\packages\core\src\tools\write-file.ts) - 写入文件工具
- [workspaceContext.ts](file:///d:\Code_AI\gemini-cli\packages\core\src\utils\workspaceContext.ts) - 工作区上下文管理
- [paths.ts](file:///d:\Code_AI\gemini-cli\packages\core\src\utils\paths.ts) - 路径工具函数
- [config.ts (CLI)](file:///d:\Code_AI\gemini-cli\packages\cli\src\config\config.ts) - CLI 配置和交互模式判断
